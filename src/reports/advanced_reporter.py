"""
ê³ ê¸‰ ë¦¬í¬íŠ¸ ìƒì„±ê¸°
- ìƒì„¸í•œ ì„±ê³¼ ì§€í‘œ ì„¤ëª…
- HTML/MD ë¦¬í¬íŠ¸ ìƒì„±
- ë¦¬ë°¸ëŸ°ì‹± ë¶„ì„
"""

import pandas as pd
import numpy as np
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Any
import plotly.graph_objects as go
from plotly.subplots import make_subplots


class AdvancedReporter:
    """ê³ ê¸‰ ë¦¬í¬íŠ¸ ìƒì„±ê¸°"""
    
    def __init__(self, results: Dict, portfolio_specs: Dict):
        self.results = results
        self.portfolio_specs = portfolio_specs
    
    def generate_html_report(self, output_path: Path, timestamp: str) -> Path:
        """ìƒì„¸ HTML ë¦¬í¬íŠ¸ ìƒì„±"""
        
        # Plotly ì°¨íŠ¸ ìƒì„±
        fig = self._create_plotly_charts()
        
        # ë©”íŠ¸ë¦­ìŠ¤ í…Œì´ë¸” ìƒì„±
        metrics_html = self._create_metrics_table_html()
        
        # HTML í…œí”Œë¦¿
        html_content = f"""<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{self.portfolio_specs['name']} - í¬íŠ¸í´ë¦¬ì˜¤ ë¶„ì„ ë¦¬í¬íŠ¸</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        {self._get_css_styles()}
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ“Š {self.portfolio_specs['name']}</h1>
            <p>í¬íŠ¸í´ë¦¬ì˜¤ ì¢…í•© ë¶„ì„ ë¦¬í¬íŠ¸</p>
            <div class="portfolio-info">
                <p><strong>ë¶„ì„ ê¸°ê°„:</strong> {self.portfolio_specs['start_date']} ~ {self.portfolio_specs['end_date']}</p>
                <p><strong>êµ¬ì„± ì¢…ëª©:</strong> {', '.join(self.portfolio_specs['tickers'])}</p>
                <p><strong>íˆ¬ì ë¹„ì¤‘:</strong> {', '.join([f'{t}: {w:.1%}' for t, w in zip(self.portfolio_specs['tickers'], self.portfolio_specs['weights'])])}</p>
                <p><strong>ê±°ë˜ì¼ìˆ˜:</strong> {self.portfolio_specs['trading_days']}ì¼</p>
            </div>
        </div>
        
        <div class="section">
            <h2>ğŸ“ˆ ì¸í„°ë™í‹°ë¸Œ ì°¨íŠ¸ ë¶„ì„</h2>
            <div class="chart-container">
                {fig.to_html(include_plotlyjs='cdn', div_id='interactive-charts')}
            </div>
        </div>
        
        <div class="section">
            <h2>ğŸ“Š ìƒì„¸ ì„±ê³¼ ì§€í‘œ</h2>
            {metrics_html}
        </div>
        
        <div class="section">
            <h2>ğŸ¯ í•µì‹¬ ì¸ì‚¬ì´íŠ¸</h2>
            {self._generate_insights_html()}
        </div>
        
        <div class="section">
            <h2>ğŸ“š ì§€í‘œ ì„¤ëª…</h2>
            {self._generate_metrics_explanation_html()}
        </div>
        
        <div class="section">
            <h2>ğŸ“‹ ë¦¬ë°¸ëŸ°ì‹± ìƒì„¸ ì •ë³´</h2>
            {self._generate_rebalancing_info_html()}
        </div>
        
        <div class="footer">
            <p>Generated by Stock Forecast Lab | {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
            <p>Powered by Python, Plotly & Advanced Analytics</p>
        </div>
    </div>
</body>
</html>"""
        
        html_path = output_path / f"portfolio_report_{timestamp}.html"
        with open(html_path, 'w', encoding='utf-8') as f:
            f.write(html_content)
        
        return html_path
    
    def _create_plotly_charts(self) -> go.Figure:
        """Plotly ì¸í„°ë™í‹°ë¸Œ ì°¨íŠ¸ ìƒì„±"""
        
        fig = make_subplots(
            rows=3, cols=2,
            subplot_titles=(
                'Portfolio Performance Comparison',
                'Risk-Return Analysis',
                'Rebalancing Cost Analysis', 
                'Rolling Sharpe Ratio',
                'Drawdown Analysis',
                'Monthly Returns Distribution'
            ),
            specs=[[{}, {}], [{}, {}], [{}, {}]],
            vertical_spacing=0.08,
            horizontal_spacing=0.08
        )
        
        colors = ['#2E86AB', '#A23B72', '#F18F01', '#C73E1D', '#7209B7']
        strategies = list(self.results.keys())
        periods = list(self.results[strategies[0]].keys())
        
        # 1. í¬íŠ¸í´ë¦¬ì˜¤ ì„±ê³¼ ë¹„êµ
        color_idx = 0
        for strategy in strategies:
            for period in periods:
                result = self.results[strategy][period] 
                cumulative = result['portfolio_values'] / result['portfolio_values'].iloc[0]
                
                fig.add_trace(
                    go.Scatter(
                        x=cumulative.index,
                        y=cumulative.values,
                        mode='lines',
                        name=f'{strategy}_{period}',
                        line=dict(color=colors[color_idx % len(colors)], width=2),
                        hovertemplate='Date: %{x}<br>Value: %{y:.3f}<extra></extra>',
                        showlegend=True
                    ),
                    row=1, col=1
                )
                color_idx += 1
        
        # 2. ìœ„í—˜-ìˆ˜ìµë¥  ë¶„ì„
        for i, strategy in enumerate(strategies):
            returns_data = []
            risk_data = []
            period_labels = []
            
            for period in periods:
                metrics = self.results[strategy][period]['metrics']
                returns_data.append(metrics['cagr'] * 100)
                risk_data.append(metrics['volatility'] * 100)
                period_labels.append(period)
            
            fig.add_trace(
                go.Scatter(
                    x=risk_data,
                    y=returns_data,
                    mode='markers+text',
                    name=strategy,
                    text=period_labels,
                    textposition='top center',
                    marker=dict(size=15, color=colors[i], opacity=0.8),
                    hovertemplate='Strategy: %{fullData.name}<br>Risk: %{x:.1f}%<br>Return: %{y:.1f}%<extra></extra>',
                    showlegend=False
                ),
                row=1, col=2
            )
        
        # 3. ë¦¬ë°¸ëŸ°ì‹± ë¹„ìš© ë¶„ì„
        cost_data = []
        strategy_period_labels = []
        
        for strategy in strategies:
            for period in periods:
                result = self.results[strategy][period]
                cost_data.append(result['total_rebalancing_cost'])
                strategy_period_labels.append(f"{strategy}_{period}")
        
        fig.add_trace(
            go.Bar(
                x=strategy_period_labels,
                y=cost_data,
                marker_color=colors[:len(cost_data)],
                text=[f'${cost:.0f}' for cost in cost_data],
                textposition='outside',
                showlegend=False,
                hovertemplate='Strategy: %{x}<br>Cost: $%{y:.0f}<extra></extra>'
            ),
            row=2, col=1
        )
        
        # 4. ë¡¤ë§ ìƒ¤í”„ ë¹„ìœ¨
        color_idx = 0
        for strategy in strategies:
            period = periods[0]
            result = self.results[strategy][period]
            returns = result['portfolio_returns']
            rolling_sharpe = returns.rolling(60).mean() / returns.rolling(60).std() * np.sqrt(252)
            
            fig.add_trace(
                go.Scatter(
                    x=rolling_sharpe.index,
                    y=rolling_sharpe.values,
                    mode='lines',
                    name=f'{strategy}_rolling_sharpe',
                    line=dict(color=colors[color_idx], width=2),
                    hovertemplate='Date: %{x}<br>Sharpe: %{y:.3f}<extra></extra>',
                    showlegend=False
                ),
                row=2, col=2
            )
            color_idx += 1
        
        fig.add_hline(y=0, line_dash='dash', line_color='gray', opacity=0.5, row=2, col=2)
        
        # 5. ë“œë¡œìš°ë‹¤ìš´ ë¶„ì„
        color_idx = 0
        for strategy in strategies:
            period = periods[0]
            result = self.results[strategy][period]
            cumulative = result['portfolio_values'] / result['portfolio_values'].iloc[0]
            rolling_max = cumulative.expanding().max()
            drawdown = (cumulative - rolling_max) / rolling_max
            
            fig.add_trace(
                go.Scatter(
                    x=drawdown.index,
                    y=drawdown.values * 100,
                    mode='lines',
                    fill='tonexty' if color_idx == 0 else None,
                    name=f'{strategy}_drawdown',
                    line=dict(color=colors[color_idx], width=2),
                    hovertemplate='Date: %{x}<br>Drawdown: %{y:.2f}%<extra></extra>',
                    showlegend=False
                ),
                row=3, col=1
            )
            color_idx += 1
        
        # 6. ì›”ë³„ ìˆ˜ìµë¥  ë¶„í¬
        strategy = strategies[0]
        period = periods[0]
        result = self.results[strategy][period]
        monthly_returns = result['portfolio_returns'].resample('M').apply(lambda x: (1 + x).prod() - 1)
        
        fig.add_trace(
            go.Histogram(
                x=monthly_returns.values * 100,
                nbinsx=20,
                name='Monthly Returns',
                marker_color=colors[0],
                opacity=0.7,
                showlegend=False,
                hovertemplate='Return: %{x:.1f}%<br>Count: %{y}<extra></extra>'
            ),
            row=3, col=2
        )
        
        # ë ˆì´ì•„ì›ƒ ì—…ë°ì´íŠ¸
        fig.update_layout(
            title={
                'text': f'ğŸ† {self.portfolio_specs["name"]} - ì¢…í•© ë¶„ì„ ë¦¬í¬íŠ¸',
                'x': 0.5,
                'font': {'size': 24, 'family': 'Arial Black'}
            },
            height=1200,
            template='plotly_white',
            showlegend=True,
            legend=dict(
                orientation='h',
                yanchor='bottom',
                y=1.02,
                xanchor='right',
                x=1
            )
        )
        
        # Yì¶• ë ˆì´ë¸” ì„¤ì •
        fig.update_yaxes(title_text='Portfolio Value', row=1, col=1)
        fig.update_yaxes(title_text='Annual Return (%)', row=1, col=2)
        fig.update_xaxes(title_text='Annual Volatility (%)', row=1, col=2)
        fig.update_yaxes(title_text='Cost ($)', row=2, col=1)
        fig.update_yaxes(title_text='Sharpe Ratio', row=2, col=2)
        fig.update_yaxes(title_text='Drawdown (%)', row=3, col=1)
        fig.update_yaxes(title_text='Frequency', row=3, col=2)
        fig.update_xaxes(title_text='Monthly Return (%)', row=3, col=2)
        
        return fig
    
    def _create_metrics_table_html(self) -> str:
        """ë©”íŠ¸ë¦­ìŠ¤ í…Œì´ë¸” HTML ìƒì„±"""
        
        html = '<div class="metrics-grid">'
        
        strategies = list(self.results.keys())
        periods = list(self.results[strategies[0]].keys())
        
        for strategy in strategies:
            html += f'<div class="metric-card"><h3>{strategy.replace("_", " ").title()} Strategy</h3>'
            html += '<table class="metric-table">'
            html += '<tr><th>Metric</th>'
            for period in periods:
                html += f'<th>{period}</th>'
            html += '</tr>'
            
            # ì£¼ìš” ì§€í‘œë“¤
            metric_names = [
                ('Total Return', 'total_return', '{:.2%}'),
                ('CAGR', 'cagr', '{:.2%}'),
                ('Volatility', 'volatility', '{:.2%}'),
                ('Sharpe Ratio', 'sharpe_ratio', '{:.3f}'),
                ('Sortino Ratio', 'sortino_ratio', '{:.3f}'),
                ('Calmar Ratio', 'calmar_ratio', '{:.3f}'),
                ('Max Drawdown', 'max_drawdown', '{:.2%}'),
                ('VaR (95%)', 'var_95', '{:.2%}'),
                ('Win Rate', 'win_rate', '{:.2%}'),
                ('Rebalancing Cost', 'total_rebalancing_cost', '${:.0f}'),
                ('Rebalancing Count', 'rebalancing_count', '{:.0f}')
            ]
            
            for display_name, key, format_str in metric_names:
                html += f'<tr><td>{display_name}</td>'
                for period in periods:
                    result = self.results[strategy][period]
                    if key in ['total_rebalancing_cost', 'rebalancing_count']:
                        value = result[key]
                    else:
                        value = result['metrics'][key]
                    
                    if pd.isna(value) or np.isinf(value):
                        formatted_value = 'N/A'
                    else:
                        try:
                            if key == 'total_rebalancing_cost':
                                formatted_value = format_str.format(value)
                            else:
                                formatted_value = format_str.format(value)
                        except:
                            formatted_value = str(value)
                    
                    html += f'<td>{formatted_value}</td>'
                html += '</tr>'
            
            html += '</table></div>'
        
        html += '</div>'
        return html
    
    def _generate_insights_html(self) -> str:
        """í•µì‹¬ ì¸ì‚¬ì´íŠ¸ HTML ìƒì„±"""
        
        strategies = list(self.results.keys())
        periods = list(self.results[strategies[0]].keys())
        
        # ìµœê³  ì„±ê³¼ ì „ëµ/ê¸°ê°„ ì°¾ê¸°
        best_return = -float('inf')
        best_sharpe = -float('inf')
        best_return_combo = ""
        best_sharpe_combo = ""
        
        for strategy in strategies:
            for period in periods:
                metrics = self.results[strategy][period]['metrics']
                
                if metrics['cagr'] > best_return:
                    best_return = metrics['cagr']
                    best_return_combo = f"{strategy}_{period}"
                
                if metrics['sharpe_ratio'] > best_sharpe:
                    best_sharpe = metrics['sharpe_ratio']
                    best_sharpe_combo = f"{strategy}_{period}"
        
        insights_html = f"""
        <div class="highlight">
            <h3>ğŸ† ìµœê³  ì„±ê³¼ ì¡°í•©</h3>
            <p><strong>ìµœê³  ìˆ˜ìµë¥ :</strong> {best_return_combo} - {best_return:.2%} CAGR</p>
            <p><strong>ìµœê³  ìƒ¤í”„ë¹„ìœ¨:</strong> {best_sharpe_combo} - {best_sharpe:.3f}</p>
        </div>
        
        <div class="explanation">
            <h4>ğŸ” ì „ëµë³„ íŠ¹ì§•</h4>
            <ul>
                <li><strong>Equal Weight:</strong> ëª¨ë“  ì¢…ëª©ì— ë™ì¼í•œ ë¹„ì¤‘ì„ í• ë‹¹. ë‹¨ìˆœí•˜ì§€ë§Œ íš¨ê³¼ì ì¸ ë¶„ì‚°íˆ¬ì</li>
                <li><strong>Vol Parity:</strong> ë³€ë™ì„±ì— ë°˜ë¹„ë¡€í•˜ì—¬ ë¹„ì¤‘ ì¡°ì •. ë¦¬ìŠ¤í¬ íŒ¨ë¦¬í‹° ì „ëµì˜ ì¼ì¢…</li>
            </ul>
        </div>
        
        <div class="explanation">
            <h4>ğŸ“… ë¦¬ë°¸ëŸ°ì‹± ì£¼ê¸°ë³„ íŠ¹ì§•</h4>
            <ul>
                <li><strong>1M (ì›”ê°„):</strong> ê°€ì¥ ë¹ˆë²ˆí•œ ë¦¬ë°¸ëŸ°ì‹±, ë†’ì€ ê±°ë˜ë¹„ìš©, ì‹œì¥ ë³€í™”ì— ë¯¼ê°í•œ ëŒ€ì‘</li>
                <li><strong>3M (ë¶„ê¸°):</strong> ê· í˜•ì¡íŒ ì ‘ê·¼, ì ë‹¹í•œ ê±°ë˜ë¹„ìš©ê³¼ ì‹œì¥ ëŒ€ì‘</li>
                <li><strong>6M (ë°˜ê¸°):</strong> ë‚®ì€ ê±°ë˜ë¹„ìš©, ì¥ê¸° íŠ¸ë Œë“œ í¬ì°©</li>
                <li><strong>1Y (ì—°ê°„):</strong> ìµœì†Œ ê±°ë˜ë¹„ìš©, Buy & Holdì™€ ìœ ì‚¬</li>
            </ul>
        </div>
        """
        
        return insights_html
    
    def _generate_metrics_explanation_html(self) -> str:
        """ì§€í‘œ ì„¤ëª… HTML ìƒì„±"""
        
        explanations = {
            "ìˆ˜ìµë¥  ì§€í‘œ": {
                "Total Return (ì´ ìˆ˜ìµë¥ )": "íˆ¬ì ê¸°ê°„ ë™ì•ˆì˜ ì „ì²´ ìˆ˜ìµë¥ . (ìµœì¢…ê°€ì¹˜ - ì´ˆê¸°ê°€ì¹˜) / ì´ˆê¸°ê°€ì¹˜",
                "CAGR (ì—°í‰ê·  ë³µí•©ì„±ì¥ë¥ )": "íˆ¬ì ê¸°ê°„ì„ ì—°ë‹¨ìœ„ë¡œ í™˜ì‚°í•œ ë³µí•© ì„±ì¥ë¥ . ì‹œê°„ì„ ê³ ë ¤í•œ ì •í™•í•œ ìˆ˜ìµë¥  ì§€í‘œ",
                "Volatility (ë³€ë™ì„±)": "ìˆ˜ìµë¥ ì˜ í‘œì¤€í¸ì°¨ë¥¼ ì—°ìœ¨í™”í•œ ê°’. íˆ¬ìì˜ ìœ„í—˜ë„ë¥¼ ë‚˜íƒ€ëƒ„"
            },
            "ìœ„í—˜ ì¡°ì • ì§€í‘œ": {
                "Sharpe Ratio (ìƒ¤í”„ ë¹„ìœ¨)": "(í¬íŠ¸í´ë¦¬ì˜¤ ìˆ˜ìµë¥  - ë¬´ìœ„í—˜ ìˆ˜ìµë¥ ) / ë³€ë™ì„±. ìœ„í—˜ ëŒ€ë¹„ ì´ˆê³¼ìˆ˜ìµë¥  ì¸¡ì •",
                "Sortino Ratio (ì†Œë¥´í‹°ë…¸ ë¹„ìœ¨)": "ìƒ¤í”„ ë¹„ìœ¨ê³¼ ìœ ì‚¬í•˜ë‚˜ í•˜ë°© ë³€ë™ì„±ë§Œ ê³ ë ¤. ì†ì‹¤ ìœ„í—˜ì— ë” ì§‘ì¤‘",
                "Calmar Ratio (ì¹¼ë§ˆ ë¹„ìœ¨)": "CAGR / ìµœëŒ€ë‚™í­. ìµœëŒ€ ì†ì‹¤ ëŒ€ë¹„ ìˆ˜ìµë¥ ì„ ë‚˜íƒ€ëƒ„",
                "Information Ratio (ì •ë³´ ë¹„ìœ¨)": "ë²¤ì¹˜ë§ˆí¬ ëŒ€ë¹„ ì´ˆê³¼ìˆ˜ìµë¥ ì˜ ì¼ê´€ì„±ì„ ì¸¡ì •. ì•¡í‹°ë¸Œ ìš´ìš© íš¨ìœ¨ì„± ì§€í‘œ"
            },
            "ìœ„í—˜ ì§€í‘œ": {
                "Max Drawdown (ìµœëŒ€ ë‚™í­)": "ìµœê³ ì  ëŒ€ë¹„ ìµœëŒ€ í•˜ë½í­. íˆ¬ììê°€ ê²½í—˜í•  ìˆ˜ ìˆëŠ” ìµœëŒ€ ì†ì‹¤",
                "VaR (Value at Risk)": "95% ì‹ ë¢°ë„ì—ì„œ ì˜ˆìƒë˜ëŠ” ìµœëŒ€ ì¼ì¼ ì†ì‹¤. í†µê³„ì  ìœ„í—˜ ì¸¡ì •",
                "CVaR (Conditional VaR)": "VaRì„ ì´ˆê³¼í•˜ëŠ” ì†ì‹¤ì˜ í‰ê· . ê·¹ë‹¨ì  ì†ì‹¤ ìƒí™©ì˜ í‰ê·  í¬ê¸°",
                "Downside Volatility (í•˜ë°© ë³€ë™ì„±)": "í‰ê·  ì´í•˜ ìˆ˜ìµë¥ ì˜ ë³€ë™ì„±ë§Œ ì¸¡ì •. ì†ì‹¤ ì¸¡ë©´ì˜ ìœ„í—˜ë„"
            },
            "ì¼ê´€ì„± ì§€í‘œ": {
                "Win Rate (ìŠ¹ë¥ )": "ì–‘ì˜ ìˆ˜ìµë¥ ì„ ê¸°ë¡í•œ ê±°ë˜ì¼ì˜ ë¹„ìœ¨. ì¼ê´€ì„±ì„ ë‚˜íƒ€ëƒ„",
                "Profit Factor (ì†ìµë¹„)": "í‰ê·  ì´ìµ / í‰ê·  ì†ì‹¤. ìˆ˜ìµ ê±°ë˜ì™€ ì†ì‹¤ ê±°ë˜ì˜ í¬ê¸° ë¹„êµ",
                "Monthly Win Rate (ì›”ê°„ ìŠ¹ë¥ )": "ì–‘ì˜ ì›”ê°„ ìˆ˜ìµë¥ ì„ ê¸°ë¡í•œ ë‹¬ì˜ ë¹„ìœ¨",
                "Max Consecutive Wins/Losses": "ìµœëŒ€ ì—°ì† ìƒìŠ¹/í•˜ë½ ì¼ìˆ˜. ì¶”ì„¸ì˜ ì§€ì†ì„±ì„ ë‚˜íƒ€ëƒ„"
            },
            "ì‹œì¥ ì§€í‘œ": {
                "Beta (ë² íƒ€)": "ì‹œì¥(ë²¤ì¹˜ë§ˆí¬) ëŒ€ë¹„ ë¯¼ê°ë„. 1ë³´ë‹¤ í¬ë©´ ì‹œì¥ë³´ë‹¤ ë³€ë™ì„± í° ìì‚°",
                "Alpha (ì•ŒíŒŒ)": "CAPM ëª¨ë¸ ê¸°ì¤€ ì´ˆê³¼ìˆ˜ìµë¥ . í¬íŠ¸í´ë¦¬ì˜¤ ë§¤ë‹ˆì €ì˜ ì‹¤ë ¥ì„ ë‚˜íƒ€ëƒ„"
            }
        }
        
        html = ""
        for category, metrics in explanations.items():
            html += f'<div class="explanation"><h4>ğŸ“Š {category}</h4><ul>'
            for metric, explanation in metrics.items():
                html += f'<li><strong>{metric}:</strong> {explanation}</li>'
            html += '</ul></div>'
        
        return html
    
    def _generate_rebalancing_info_html(self) -> str:
        """ë¦¬ë°¸ëŸ°ì‹± ìƒì„¸ ì •ë³´ HTML ìƒì„±"""
        
        strategies = list(self.results.keys())
        periods = list(self.results[strategies[0]].keys())
        
        html = '<div class="metrics-grid">'
        
        for strategy in strategies:
            html += f'<div class="metric-card"><h3>{strategy.replace("_", " ").title()} - ë¦¬ë°¸ëŸ°ì‹± ë¶„ì„</h3>'
            
            for period in periods:
                result = self.results[strategy][period]
                rebalance_dates = result['rebalance_dates']
                total_cost = result['total_rebalancing_cost']
                rebalance_count = result['rebalancing_count']
                
                html += f'<h4>{period} ë¦¬ë°¸ëŸ°ì‹±</h4>'
                html += f'<p><strong>ì´ ë¦¬ë°¸ëŸ°ì‹± íšŸìˆ˜:</strong> {rebalance_count}íšŒ</p>'
                html += f'<p><strong>ì´ ê±°ë˜ë¹„ìš©:</strong> ${total_cost:.2f}</p>'
                html += f'<p><strong>íšŒë‹¹ í‰ê·  ë¹„ìš©:</strong> ${total_cost/max(rebalance_count, 1):.2f}</p>'
                
                # ë¦¬ë°¸ëŸ°ì‹± ë‚ ì§œ (ì²˜ìŒ 5ê°œë§Œ)
                if len(rebalance_dates) > 0:
                    html += '<p><strong>ë¦¬ë°¸ëŸ°ì‹± ë‚ ì§œ (ì²˜ìŒ 5íšŒ):</strong></p><ul>'
                    for date in rebalance_dates[:5]:
                        html += f'<li>{date.strftime("%Y-%m-%d")}</li>'
                    if len(rebalance_dates) > 5:
                        html += f'<li>... ì™¸ {len(rebalance_dates)-5}íšŒ</li>'
                    html += '</ul>'
                
                # ë™ì  ê°€ì¤‘ì¹˜ ì •ë³´ (í•´ë‹¹í•˜ëŠ” ê²½ìš°)
                if 'dynamic_weights' in result:
                    weights_df = result['dynamic_weights']
                    html += '<p><strong>í‰ê·  íˆ¬ì ë¹„ì¤‘:</strong></p><ul>'
                    avg_weights = weights_df.mean()
                    for ticker, weight in avg_weights.items():
                        html += f'<li>{ticker}: {weight:.1%}</li>'
                    html += '</ul>'
                else:
                    html += '<p><strong>ê³ ì • íˆ¬ì ë¹„ì¤‘:</strong></p><ul>'
                    for ticker, weight in zip(self.portfolio_specs['tickers'], result['weights']):
                        html += f'<li>{ticker}: {weight:.1%}</li>'
                    html += '</ul>'
                
                html += '<hr>'
            
            html += '</div>'
        
        html += '</div>'
        
        return html
    
    def _get_css_styles(self) -> str:
        """CSS ìŠ¤íƒ€ì¼ ë°˜í™˜"""
        return """
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            background: white;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            text-align: center;
        }
        
        .header h1 {
            color: #2E86AB;
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        .portfolio-info {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }
        
        .section {
            background: white;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 20px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
        }
        
        .section h2 {
            color: #2E86AB;
            border-bottom: 3px solid #2E86AB;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .metric-card {
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            padding: 20px;
            border-radius: 10px;
            border-left: 5px solid #2E86AB;
        }
        
        .metric-card h3 {
            color: #2E86AB;
            margin-bottom: 15px;
            font-size: 1.2em;
        }
        
        .metric-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            font-size: 0.9em;
        }
        
        .metric-table th, .metric-table td {
            padding: 8px 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        
        .metric-table th {
            background-color: #f8f9fa;
            font-weight: 600;
            color: #2E86AB;
        }
        
        .metric-table tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        
        .highlight {
            background: linear-gradient(45deg, #FFE066, #FF6B6B);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            color: #333;
        }
        
        .chart-container {
            margin: 30px 0;
            padding: 20px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .explanation {
            background: #e3f2fd;
            padding: 20px;
            border-radius: 10px;
            margin: 15px 0;
            border-left: 4px solid #2196f3;
        }
        
        .explanation h4 {
            color: #1976d2;
            margin-bottom: 10px;
        }
        
        .footer {
            background: #333;
            color: white;
            text-align: center;
            padding: 20px;
            border-radius: 10px;
            margin-top: 30px;
        }
        
        @media (max-width: 768px) {
            .metrics-grid {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2em;
            }
        }
        """
    
    def generate_markdown_report(self, output_path: Path, timestamp: str) -> Path:
        """ë§ˆí¬ë‹¤ìš´ ë¦¬í¬íŠ¸ ìƒì„±"""
        
        strategies = list(self.results.keys())
        periods = list(self.results[strategies[0]].keys())
        
        # ìµœê³  ì„±ê³¼ ì°¾ê¸°
        best_return = -float('inf')
        best_sharpe = -float('inf')
        best_return_combo = ""
        best_sharpe_combo = ""
        
        for strategy in strategies:
            for period in periods:
                metrics = self.results[strategy][period]['metrics']
                
                if metrics['cagr'] > best_return:
                    best_return = metrics['cagr']
                    best_return_combo = f"{strategy}_{period}"
                
                if metrics['sharpe_ratio'] > best_sharpe:
                    best_sharpe = metrics['sharpe_ratio']
                    best_sharpe_combo = f"{strategy}_{period}"
        
        md_content = f"""# ğŸ“Š {self.portfolio_specs['name']} - í¬íŠ¸í´ë¦¬ì˜¤ ë¶„ì„ ë¦¬í¬íŠ¸

## ğŸ“‹ ê¸°ë³¸ ì •ë³´

- **ë¶„ì„ ê¸°ê°„**: {self.portfolio_specs['start_date']} ~ {self.portfolio_specs['end_date']}
- **êµ¬ì„± ì¢…ëª©**: {', '.join(self.portfolio_specs['tickers'])}
- **íˆ¬ì ë¹„ì¤‘**: {', '.join([f'{t}: {w:.1%}' for t, w in zip(self.portfolio_specs['tickers'], self.portfolio_specs['weights'])])}
- **ê±°ë˜ì¼ìˆ˜**: {self.portfolio_specs['trading_days']}ì¼
- **ë¶„ì„ ì „ëµ**: {', '.join(strategies)}
- **ë¦¬ë°¸ëŸ°ì‹± ì£¼ê¸°**: {', '.join(periods)}

## ğŸ† í•µì‹¬ ê²°ê³¼

### ìµœê³  ì„±ê³¼ ì¡°í•©
- **ìµœê³  ìˆ˜ìµë¥ **: {best_return_combo} - **{best_return:.2%}** CAGR
- **ìµœê³  ìƒ¤í”„ë¹„ìœ¨**: {best_sharpe_combo} - **{best_sharpe:.3f}**

## ğŸ“Š ì „ëµë³„ ìƒì„¸ ì„±ê³¼

{self._generate_markdown_metrics_table()}

## ğŸ¯ ì „ëµ ë¶„ì„

### Equal Weight (ë™ì¼ê°€ì¤‘) ì „ëµ
- **íŠ¹ì§•**: ëª¨ë“  ì¢…ëª©ì— ë™ì¼í•œ ë¹„ì¤‘ í• ë‹¹
- **ì¥ì **: ë‹¨ìˆœí•¨, ìë™ ë¦¬ë°¸ëŸ°ì‹± íš¨ê³¼, ì¤‘ì†Œí˜•ì£¼ í¸í–¥
- **ë‹¨ì **: ì‹œê°€ì´ì•¡ ë¬´ì‹œ, ê³ ë³€ë™ì„± ì¢…ëª©ì˜ ê³¼ë„í•œ ì˜í–¥

### Volatility Parity (ë³€ë™ì„± íŒ¨ë¦¬í‹°) ì „ëµ  
- **íŠ¹ì§•**: ë³€ë™ì„±ì— ë°˜ë¹„ë¡€í•˜ì—¬ ë¹„ì¤‘ ì¡°ì •
- **ì¥ì **: ë¦¬ìŠ¤í¬ ê· ë“± ë¶„ì‚°, ì•ˆì •ì  ìˆ˜ìµ
- **ë‹¨ì **: ë³µì¡í•œ ê³„ì‚°, ì €ë³€ë™ì„± ìì‚° í¸í–¥

## ğŸ“… ë¦¬ë°¸ëŸ°ì‹± ì£¼ê¸° ë¶„ì„

{self._generate_markdown_rebalancing_analysis()}

## ğŸ“š ì„±ê³¼ ì§€í‘œ í•´ì„¤

### ìˆ˜ìµë¥  ì§€í‘œ
- **Total Return**: íˆ¬ì ê¸°ê°„ ë™ì•ˆì˜ ì „ì²´ ìˆ˜ìµë¥ 
- **CAGR**: ì—°í‰ê·  ë³µí•©ì„±ì¥ë¥ , ì‹œê°„ì„ ê³ ë ¤í•œ ì •í™•í•œ ìˆ˜ìµë¥ 
- **Volatility**: ìˆ˜ìµë¥ ì˜ ì—°ìœ¨í™”ëœ í‘œì¤€í¸ì°¨, ìœ„í—˜ë„ ì¸¡ì •

### ìœ„í—˜ ì¡°ì • ì§€í‘œ  
- **Sharpe Ratio**: ìœ„í—˜ ëŒ€ë¹„ ì´ˆê³¼ìˆ˜ìµë¥ , ë†’ì„ìˆ˜ë¡ ì¢‹ìŒ
- **Sortino Ratio**: í•˜ë°© ìœ„í—˜ë§Œ ê³ ë ¤í•œ ìˆ˜ìµë¥  ì§€í‘œ
- **Calmar Ratio**: ìµœëŒ€ ë‚™í­ ëŒ€ë¹„ ìˆ˜ìµë¥ 

### ìœ„í—˜ ì§€í‘œ
- **Max Drawdown**: ìµœê³ ì  ëŒ€ë¹„ ìµœëŒ€ í•˜ë½í­
- **VaR (95%)**: 95% ì‹ ë¢°ë„ì—ì„œ ì˜ˆìƒ ìµœëŒ€ ì¼ì¼ ì†ì‹¤
- **CVaR**: VaR ì´ˆê³¼ ì†ì‹¤ì˜ í‰ê· ê°’

### ì¼ê´€ì„± ì§€í‘œ
- **Win Rate**: ì–‘ì˜ ìˆ˜ìµë¥  ê¸°ë¡ ë¹„ìœ¨
- **Profit Factor**: í‰ê·  ì´ìµ ëŒ€ë¹„ í‰ê·  ì†ì‹¤ ë¹„ìœ¨

## ğŸ’¡ íˆ¬ì ê°€ì´ë“œë¼ì¸

### ë³´ìˆ˜ì  íˆ¬ìì
- **ì¶”ì²œ**: Volatility Parity + 6M/1Y ë¦¬ë°¸ëŸ°ì‹±
- **ì´ìœ **: ë‚®ì€ ë³€ë™ì„±, ì•ˆì •ì  ìˆ˜ìµë¥  ê³¡ì„ 

### ì ê·¹ì  íˆ¬ìì
- **ì¶”ì²œ**: Equal Weight + 1M/3M ë¦¬ë°¸ëŸ°ì‹±  
- **ì´ìœ **: ë†’ì€ ì ˆëŒ€ ìˆ˜ìµë¥ , ì‹œì¥ ê¸°íšŒ ì ê·¹ í™œìš©

### ê· í˜• íˆ¬ìì
- **ì¶”ì²œ**: ë‘ ì „ëµ í˜¼í•© + 3M ë¦¬ë°¸ëŸ°ì‹±
- **ì´ìœ **: ìœ„í—˜ê³¼ ìˆ˜ìµì˜ ê· í˜•

## âš ï¸ ì£¼ì˜ì‚¬í•­

1. **ê³¼ê±° ì„±ê³¼ëŠ” ë¯¸ë˜ ìˆ˜ìµì„ ë³´ì¥í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤**
2. **ê±°ë˜ë¹„ìš©ì´ ì‹¤ì œ ìˆ˜ìµë¥ ì— ì˜í–¥ì„ ì¤„ ìˆ˜ ìˆìŠµë‹ˆë‹¤**
3. **ì‹œì¥ í™˜ê²½ ë³€í™”ì— ë”°ë¥¸ ì „ëµ íš¨ê³¼ì„± ë³€ë™ ê°€ëŠ¥**
4. **ë¶„ì‚°íˆ¬ìë¥¼ í†µí•œ ìœ„í—˜ ê´€ë¦¬ê°€ ì¤‘ìš”í•©ë‹ˆë‹¤**

## ğŸ“ˆ ê²°ë¡ 

{self._generate_markdown_conclusion()}

---

*Generated by Stock Forecast Lab on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*
"""
        
        md_path = output_path / f"portfolio_report_{timestamp}.md"
        with open(md_path, 'w', encoding='utf-8') as f:
            f.write(md_content)
        
        return md_path
    
    def _generate_markdown_metrics_table(self) -> str:
        """ë§ˆí¬ë‹¤ìš´ ë©”íŠ¸ë¦­ìŠ¤ í…Œì´ë¸” ìƒì„±"""
        
        strategies = list(self.results.keys())
        periods = list(self.results[strategies[0]].keys())
        
        md = ""
        for strategy in strategies:
            md += f"\n### {strategy.replace('_', ' ').title()} Strategy\n\n"
            
            # í…Œì´ë¸” í—¤ë”
            md += "| Metric | " + " | ".join(periods) + " |\n"
            md += "|--------|" + "|".join(["--------"] * len(periods)) + "|\n"
            
            # ë©”íŠ¸ë¦­ ë°ì´í„°
            metric_info = [
                ('Total Return', 'total_return', '{:.2%}'),
                ('CAGR', 'cagr', '{:.2%}'),
                ('Volatility', 'volatility', '{:.2%}'),
                ('Sharpe Ratio', 'sharpe_ratio', '{:.3f}'),
                ('Sortino Ratio', 'sortino_ratio', '{:.3f}'),
                ('Max Drawdown', 'max_drawdown', '{:.2%}'),
                ('Win Rate', 'win_rate', '{:.2%}'),
                ('Rebalancing Cost', 'total_rebalancing_cost', '${:.0f}')
            ]
            
            for display_name, key, format_str in metric_info:
                md += f"| {display_name} |"
                for period in periods:
                    result = self.results[strategy][period]
                    if key in ['total_rebalancing_cost']:
                        value = result[key]
                    else:
                        value = result['metrics'][key]
                    
                    if pd.isna(value) or np.isinf(value):
                        formatted_value = 'N/A'
                    else:
                        try:
                            formatted_value = format_str.format(value)
                        except:
                            formatted_value = str(value)
                    
                    md += f" {formatted_value} |"
                md += "\n"
            
            md += "\n"
        
        return md
    
    def _generate_markdown_rebalancing_analysis(self) -> str:
        """ë§ˆí¬ë‹¤ìš´ ë¦¬ë°¸ëŸ°ì‹± ë¶„ì„ ìƒì„±"""
        
        strategies = list(self.results.keys())
        periods = list(self.results[strategies[0]].keys())
        
        md = ""
        for period in periods:
            md += f"\n### {period} ë¦¬ë°¸ëŸ°ì‹± ì£¼ê¸°\n\n"
            
            for strategy in strategies:
                result = self.results[strategy][period]
                rebalance_count = result['rebalancing_count']
                total_cost = result['total_rebalancing_cost']
                
                md += f"**{strategy.replace('_', ' ').title()}**:\n"
                md += f"- ì´ ë¦¬ë°¸ëŸ°ì‹±: {rebalance_count}íšŒ\n"
                md += f"- ì´ ê±°ë˜ë¹„ìš©: ${total_cost:.2f}\n"
                md += f"- íšŒë‹¹ í‰ê· : ${total_cost/max(rebalance_count, 1):.2f}\n\n"
        
        return md
    
    def _generate_markdown_conclusion(self) -> str:
        """ë§ˆí¬ë‹¤ìš´ ê²°ë¡  ìƒì„±"""
        
        strategies = list(self.results.keys())
        periods = list(self.results[strategies[0]].keys())
        
        # ê°„ë‹¨í•œ ê²°ë¡  ìƒì„±
        best_combo = ""
        best_cagr = -float('inf')
        
        for strategy in strategies:
            for period in periods:
                cagr = self.results[strategy][period]['metrics']['cagr']
                if cagr > best_cagr:
                    best_cagr = cagr
                    best_combo = f"{strategy}_{period}"
        
        conclusion = f"""
ë¶„ì„ ê²°ê³¼, **{best_combo}** ì¡°í•©ì´ **{best_cagr:.2%}**ì˜ CAGRë¡œ ìµœê³  ì„±ê³¼ë¥¼ ê¸°ë¡í–ˆìŠµë‹ˆë‹¤.

íˆ¬ììëŠ” ìì‹ ì˜ ìœ„í—˜ ì„±í–¥ê³¼ íˆ¬ì ëª©í‘œì— ë”°ë¼ ì ì ˆí•œ ì „ëµê³¼ ë¦¬ë°¸ëŸ°ì‹± ì£¼ê¸°ë¥¼ ì„ íƒí•´ì•¼ í•©ë‹ˆë‹¤. 
ë†’ì€ ìˆ˜ìµë¥ ì„ ì¶”êµ¬í•œë‹¤ë©´ ì ê·¹ì  ì „ëµì„, ì•ˆì •ì„±ì„ ì¤‘ì‹œí•œë‹¤ë©´ ë³´ìˆ˜ì  ì „ëµì„ ê³ ë ¤í•˜ì‹œê¸° ë°”ëë‹ˆë‹¤.

ë¬´ì—‡ë³´ë‹¤ **ë¶„ì‚°íˆ¬ìì™€ ê¾¸ì¤€í•œ ëª¨ë‹ˆí„°ë§**ì´ ì„±ê³µì ì¸ í¬íŠ¸í´ë¦¬ì˜¤ ìš´ìš©ì˜ í•µì‹¬ì…ë‹ˆë‹¤.
"""
        
        return conclusion