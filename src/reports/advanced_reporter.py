"""
고급 리포트 생성기
- 상세한 성과 지표 설명
- HTML/MD 리포트 생성
- 리밸런싱 분석
"""

import pandas as pd
import numpy as np
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Any
import plotly.graph_objects as go
from plotly.subplots import make_subplots


class AdvancedReporter:
    """고급 리포트 생성기"""
    
    def __init__(self, results: Dict, portfolio_specs: Dict):
        self.results = results
        self.portfolio_specs = portfolio_specs
    
    def generate_html_report(self, output_path: Path, timestamp: str) -> Path:
        """상세 HTML 리포트 생성"""
        
        # Plotly 차트 생성
        fig = self._create_plotly_charts()
        
        # 메트릭스 테이블 생성
        metrics_html = self._create_metrics_table_html()
        
        # HTML 템플릿
        html_content = f"""<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{self.portfolio_specs['name']} - 포트폴리오 분석 리포트</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        {self._get_css_styles()}
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>📊 {self.portfolio_specs['name']}</h1>
            <p>포트폴리오 종합 분석 리포트</p>
            <div class="portfolio-info">
                <p><strong>분석 기간:</strong> {self.portfolio_specs['start_date']} ~ {self.portfolio_specs['end_date']}</p>
                <p><strong>구성 종목:</strong> {', '.join(self.portfolio_specs['tickers'])}</p>
                <p><strong>투자 비중:</strong> {', '.join([f'{t}: {w:.1%}' for t, w in zip(self.portfolio_specs['tickers'], self.portfolio_specs['weights'])])}</p>
                <p><strong>거래일수:</strong> {self.portfolio_specs['trading_days']}일</p>
            </div>
        </div>
        
        <div class="section">
            <h2>📈 인터랙티브 차트 분석</h2>
            <div class="chart-container">
                {fig.to_html(include_plotlyjs='cdn', div_id='interactive-charts')}
            </div>
        </div>
        
        <div class="section">
            <h2>📊 상세 성과 지표</h2>
            {metrics_html}
        </div>
        
        <div class="section">
            <h2>🎯 핵심 인사이트</h2>
            {self._generate_insights_html()}
        </div>
        
        <div class="section">
            <h2>📚 지표 설명</h2>
            {self._generate_metrics_explanation_html()}
        </div>
        
        <div class="section">
            <h2>📋 리밸런싱 상세 정보</h2>
            {self._generate_rebalancing_info_html()}
        </div>
        
        <div class="footer">
            <p>Generated by Stock Forecast Lab | {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
            <p>Powered by Python, Plotly & Advanced Analytics</p>
        </div>
    </div>
</body>
</html>"""
        
        html_path = output_path / f"portfolio_report_{timestamp}.html"
        with open(html_path, 'w', encoding='utf-8') as f:
            f.write(html_content)
        
        return html_path
    
    def _create_plotly_charts(self) -> go.Figure:
        """Plotly 인터랙티브 차트 생성"""
        
        fig = make_subplots(
            rows=3, cols=2,
            subplot_titles=(
                'Portfolio Performance Comparison',
                'Risk-Return Analysis',
                'Rebalancing Cost Analysis', 
                'Rolling Sharpe Ratio',
                'Drawdown Analysis',
                'Monthly Returns Distribution'
            ),
            specs=[[{}, {}], [{}, {}], [{}, {}]],
            vertical_spacing=0.08,
            horizontal_spacing=0.08
        )
        
        colors = ['#2E86AB', '#A23B72', '#F18F01', '#C73E1D', '#7209B7']
        strategies = list(self.results.keys())
        periods = list(self.results[strategies[0]].keys())
        
        # 1. 포트폴리오 성과 비교
        color_idx = 0
        for strategy in strategies:
            for period in periods:
                result = self.results[strategy][period] 
                cumulative = result['portfolio_values'] / result['portfolio_values'].iloc[0]
                
                fig.add_trace(
                    go.Scatter(
                        x=cumulative.index,
                        y=cumulative.values,
                        mode='lines',
                        name=f'{strategy}_{period}',
                        line=dict(color=colors[color_idx % len(colors)], width=2),
                        hovertemplate='Date: %{x}<br>Value: %{y:.3f}<extra></extra>',
                        showlegend=True
                    ),
                    row=1, col=1
                )
                color_idx += 1
        
        # 2. 위험-수익률 분석
        for i, strategy in enumerate(strategies):
            returns_data = []
            risk_data = []
            period_labels = []
            
            for period in periods:
                metrics = self.results[strategy][period]['metrics']
                returns_data.append(metrics['cagr'] * 100)
                risk_data.append(metrics['volatility'] * 100)
                period_labels.append(period)
            
            fig.add_trace(
                go.Scatter(
                    x=risk_data,
                    y=returns_data,
                    mode='markers+text',
                    name=strategy,
                    text=period_labels,
                    textposition='top center',
                    marker=dict(size=15, color=colors[i], opacity=0.8),
                    hovertemplate='Strategy: %{fullData.name}<br>Risk: %{x:.1f}%<br>Return: %{y:.1f}%<extra></extra>',
                    showlegend=False
                ),
                row=1, col=2
            )
        
        # 3. 리밸런싱 비용 분석
        cost_data = []
        strategy_period_labels = []
        
        for strategy in strategies:
            for period in periods:
                result = self.results[strategy][period]
                cost_data.append(result['total_rebalancing_cost'])
                strategy_period_labels.append(f"{strategy}_{period}")
        
        fig.add_trace(
            go.Bar(
                x=strategy_period_labels,
                y=cost_data,
                marker_color=colors[:len(cost_data)],
                text=[f'${cost:.0f}' for cost in cost_data],
                textposition='outside',
                showlegend=False,
                hovertemplate='Strategy: %{x}<br>Cost: $%{y:.0f}<extra></extra>'
            ),
            row=2, col=1
        )
        
        # 4. 롤링 샤프 비율
        color_idx = 0
        for strategy in strategies:
            period = periods[0]
            result = self.results[strategy][period]
            returns = result['portfolio_returns']
            rolling_sharpe = returns.rolling(60).mean() / returns.rolling(60).std() * np.sqrt(252)
            
            fig.add_trace(
                go.Scatter(
                    x=rolling_sharpe.index,
                    y=rolling_sharpe.values,
                    mode='lines',
                    name=f'{strategy}_rolling_sharpe',
                    line=dict(color=colors[color_idx], width=2),
                    hovertemplate='Date: %{x}<br>Sharpe: %{y:.3f}<extra></extra>',
                    showlegend=False
                ),
                row=2, col=2
            )
            color_idx += 1
        
        fig.add_hline(y=0, line_dash='dash', line_color='gray', opacity=0.5, row=2, col=2)
        
        # 5. 드로우다운 분석
        color_idx = 0
        for strategy in strategies:
            period = periods[0]
            result = self.results[strategy][period]
            cumulative = result['portfolio_values'] / result['portfolio_values'].iloc[0]
            rolling_max = cumulative.expanding().max()
            drawdown = (cumulative - rolling_max) / rolling_max
            
            fig.add_trace(
                go.Scatter(
                    x=drawdown.index,
                    y=drawdown.values * 100,
                    mode='lines',
                    fill='tonexty' if color_idx == 0 else None,
                    name=f'{strategy}_drawdown',
                    line=dict(color=colors[color_idx], width=2),
                    hovertemplate='Date: %{x}<br>Drawdown: %{y:.2f}%<extra></extra>',
                    showlegend=False
                ),
                row=3, col=1
            )
            color_idx += 1
        
        # 6. 월별 수익률 분포
        strategy = strategies[0]
        period = periods[0]
        result = self.results[strategy][period]
        monthly_returns = result['portfolio_returns'].resample('M').apply(lambda x: (1 + x).prod() - 1)
        
        fig.add_trace(
            go.Histogram(
                x=monthly_returns.values * 100,
                nbinsx=20,
                name='Monthly Returns',
                marker_color=colors[0],
                opacity=0.7,
                showlegend=False,
                hovertemplate='Return: %{x:.1f}%<br>Count: %{y}<extra></extra>'
            ),
            row=3, col=2
        )
        
        # 레이아웃 업데이트
        fig.update_layout(
            title={
                'text': f'🏆 {self.portfolio_specs["name"]} - 종합 분석 리포트',
                'x': 0.5,
                'font': {'size': 24, 'family': 'Arial Black'}
            },
            height=1200,
            template='plotly_white',
            showlegend=True,
            legend=dict(
                orientation='h',
                yanchor='bottom',
                y=1.02,
                xanchor='right',
                x=1
            )
        )
        
        # Y축 레이블 설정
        fig.update_yaxes(title_text='Portfolio Value', row=1, col=1)
        fig.update_yaxes(title_text='Annual Return (%)', row=1, col=2)
        fig.update_xaxes(title_text='Annual Volatility (%)', row=1, col=2)
        fig.update_yaxes(title_text='Cost ($)', row=2, col=1)
        fig.update_yaxes(title_text='Sharpe Ratio', row=2, col=2)
        fig.update_yaxes(title_text='Drawdown (%)', row=3, col=1)
        fig.update_yaxes(title_text='Frequency', row=3, col=2)
        fig.update_xaxes(title_text='Monthly Return (%)', row=3, col=2)
        
        return fig
    
    def _create_metrics_table_html(self) -> str:
        """메트릭스 테이블 HTML 생성"""
        
        html = '<div class="metrics-grid">'
        
        strategies = list(self.results.keys())
        periods = list(self.results[strategies[0]].keys())
        
        for strategy in strategies:
            html += f'<div class="metric-card"><h3>{strategy.replace("_", " ").title()} Strategy</h3>'
            html += '<table class="metric-table">'
            html += '<tr><th>Metric</th>'
            for period in periods:
                html += f'<th>{period}</th>'
            html += '</tr>'
            
            # 주요 지표들
            metric_names = [
                ('Total Return', 'total_return', '{:.2%}'),
                ('CAGR', 'cagr', '{:.2%}'),
                ('Volatility', 'volatility', '{:.2%}'),
                ('Sharpe Ratio', 'sharpe_ratio', '{:.3f}'),
                ('Sortino Ratio', 'sortino_ratio', '{:.3f}'),
                ('Calmar Ratio', 'calmar_ratio', '{:.3f}'),
                ('Max Drawdown', 'max_drawdown', '{:.2%}'),
                ('VaR (95%)', 'var_95', '{:.2%}'),
                ('Win Rate', 'win_rate', '{:.2%}'),
                ('Rebalancing Cost', 'total_rebalancing_cost', '${:.0f}'),
                ('Rebalancing Count', 'rebalancing_count', '{:.0f}')
            ]
            
            for display_name, key, format_str in metric_names:
                html += f'<tr><td>{display_name}</td>'
                for period in periods:
                    result = self.results[strategy][period]
                    if key in ['total_rebalancing_cost', 'rebalancing_count']:
                        value = result[key]
                    else:
                        value = result['metrics'][key]
                    
                    if pd.isna(value) or np.isinf(value):
                        formatted_value = 'N/A'
                    else:
                        try:
                            if key == 'total_rebalancing_cost':
                                formatted_value = format_str.format(value)
                            else:
                                formatted_value = format_str.format(value)
                        except:
                            formatted_value = str(value)
                    
                    html += f'<td>{formatted_value}</td>'
                html += '</tr>'
            
            html += '</table></div>'
        
        html += '</div>'
        return html
    
    def _generate_insights_html(self) -> str:
        """핵심 인사이트 HTML 생성"""
        
        strategies = list(self.results.keys())
        periods = list(self.results[strategies[0]].keys())
        
        # 최고 성과 전략/기간 찾기
        best_return = -float('inf')
        best_sharpe = -float('inf')
        best_return_combo = ""
        best_sharpe_combo = ""
        
        for strategy in strategies:
            for period in periods:
                metrics = self.results[strategy][period]['metrics']
                
                if metrics['cagr'] > best_return:
                    best_return = metrics['cagr']
                    best_return_combo = f"{strategy}_{period}"
                
                if metrics['sharpe_ratio'] > best_sharpe:
                    best_sharpe = metrics['sharpe_ratio']
                    best_sharpe_combo = f"{strategy}_{period}"
        
        insights_html = f"""
        <div class="highlight">
            <h3>🏆 최고 성과 조합</h3>
            <p><strong>최고 수익률:</strong> {best_return_combo} - {best_return:.2%} CAGR</p>
            <p><strong>최고 샤프비율:</strong> {best_sharpe_combo} - {best_sharpe:.3f}</p>
        </div>
        
        <div class="explanation">
            <h4>🔍 전략별 특징</h4>
            <ul>
                <li><strong>Equal Weight:</strong> 모든 종목에 동일한 비중을 할당. 단순하지만 효과적인 분산투자</li>
                <li><strong>Vol Parity:</strong> 변동성에 반비례하여 비중 조정. 리스크 패리티 전략의 일종</li>
            </ul>
        </div>
        
        <div class="explanation">
            <h4>📅 리밸런싱 주기별 특징</h4>
            <ul>
                <li><strong>1M (월간):</strong> 가장 빈번한 리밸런싱, 높은 거래비용, 시장 변화에 민감한 대응</li>
                <li><strong>3M (분기):</strong> 균형잡힌 접근, 적당한 거래비용과 시장 대응</li>
                <li><strong>6M (반기):</strong> 낮은 거래비용, 장기 트렌드 포착</li>
                <li><strong>1Y (연간):</strong> 최소 거래비용, Buy & Hold와 유사</li>
            </ul>
        </div>
        """
        
        return insights_html
    
    def _generate_metrics_explanation_html(self) -> str:
        """지표 설명 HTML 생성"""
        
        explanations = {
            "수익률 지표": {
                "Total Return (총 수익률)": "투자 기간 동안의 전체 수익률. (최종가치 - 초기가치) / 초기가치",
                "CAGR (연평균 복합성장률)": "투자 기간을 연단위로 환산한 복합 성장률. 시간을 고려한 정확한 수익률 지표",
                "Volatility (변동성)": "수익률의 표준편차를 연율화한 값. 투자의 위험도를 나타냄"
            },
            "위험 조정 지표": {
                "Sharpe Ratio (샤프 비율)": "(포트폴리오 수익률 - 무위험 수익률) / 변동성. 위험 대비 초과수익률 측정",
                "Sortino Ratio (소르티노 비율)": "샤프 비율과 유사하나 하방 변동성만 고려. 손실 위험에 더 집중",
                "Calmar Ratio (칼마 비율)": "CAGR / 최대낙폭. 최대 손실 대비 수익률을 나타냄",
                "Information Ratio (정보 비율)": "벤치마크 대비 초과수익률의 일관성을 측정. 액티브 운용 효율성 지표"
            },
            "위험 지표": {
                "Max Drawdown (최대 낙폭)": "최고점 대비 최대 하락폭. 투자자가 경험할 수 있는 최대 손실",
                "VaR (Value at Risk)": "95% 신뢰도에서 예상되는 최대 일일 손실. 통계적 위험 측정",
                "CVaR (Conditional VaR)": "VaR을 초과하는 손실의 평균. 극단적 손실 상황의 평균 크기",
                "Downside Volatility (하방 변동성)": "평균 이하 수익률의 변동성만 측정. 손실 측면의 위험도"
            },
            "일관성 지표": {
                "Win Rate (승률)": "양의 수익률을 기록한 거래일의 비율. 일관성을 나타냄",
                "Profit Factor (손익비)": "평균 이익 / 평균 손실. 수익 거래와 손실 거래의 크기 비교",
                "Monthly Win Rate (월간 승률)": "양의 월간 수익률을 기록한 달의 비율",
                "Max Consecutive Wins/Losses": "최대 연속 상승/하락 일수. 추세의 지속성을 나타냄"
            },
            "시장 지표": {
                "Beta (베타)": "시장(벤치마크) 대비 민감도. 1보다 크면 시장보다 변동성 큰 자산",
                "Alpha (알파)": "CAPM 모델 기준 초과수익률. 포트폴리오 매니저의 실력을 나타냄"
            }
        }
        
        html = ""
        for category, metrics in explanations.items():
            html += f'<div class="explanation"><h4>📊 {category}</h4><ul>'
            for metric, explanation in metrics.items():
                html += f'<li><strong>{metric}:</strong> {explanation}</li>'
            html += '</ul></div>'
        
        return html
    
    def _generate_rebalancing_info_html(self) -> str:
        """리밸런싱 상세 정보 HTML 생성"""
        
        strategies = list(self.results.keys())
        periods = list(self.results[strategies[0]].keys())
        
        html = '<div class="metrics-grid">'
        
        for strategy in strategies:
            html += f'<div class="metric-card"><h3>{strategy.replace("_", " ").title()} - 리밸런싱 분석</h3>'
            
            for period in periods:
                result = self.results[strategy][period]
                rebalance_dates = result['rebalance_dates']
                total_cost = result['total_rebalancing_cost']
                rebalance_count = result['rebalancing_count']
                
                html += f'<h4>{period} 리밸런싱</h4>'
                html += f'<p><strong>총 리밸런싱 횟수:</strong> {rebalance_count}회</p>'
                html += f'<p><strong>총 거래비용:</strong> ${total_cost:.2f}</p>'
                html += f'<p><strong>회당 평균 비용:</strong> ${total_cost/max(rebalance_count, 1):.2f}</p>'
                
                # 리밸런싱 날짜 (처음 5개만)
                if len(rebalance_dates) > 0:
                    html += '<p><strong>리밸런싱 날짜 (처음 5회):</strong></p><ul>'
                    for date in rebalance_dates[:5]:
                        html += f'<li>{date.strftime("%Y-%m-%d")}</li>'
                    if len(rebalance_dates) > 5:
                        html += f'<li>... 외 {len(rebalance_dates)-5}회</li>'
                    html += '</ul>'
                
                # 동적 가중치 정보 (해당하는 경우)
                if 'dynamic_weights' in result:
                    weights_df = result['dynamic_weights']
                    html += '<p><strong>평균 투자 비중:</strong></p><ul>'
                    avg_weights = weights_df.mean()
                    for ticker, weight in avg_weights.items():
                        html += f'<li>{ticker}: {weight:.1%}</li>'
                    html += '</ul>'
                else:
                    html += '<p><strong>고정 투자 비중:</strong></p><ul>'
                    for ticker, weight in zip(self.portfolio_specs['tickers'], result['weights']):
                        html += f'<li>{ticker}: {weight:.1%}</li>'
                    html += '</ul>'
                
                html += '<hr>'
            
            html += '</div>'
        
        html += '</div>'
        
        return html
    
    def _get_css_styles(self) -> str:
        """CSS 스타일 반환"""
        return """
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .header {
            background: white;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            text-align: center;
        }
        
        .header h1 {
            color: #2E86AB;
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        .portfolio-info {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }
        
        .section {
            background: white;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 20px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
        }
        
        .section h2 {
            color: #2E86AB;
            border-bottom: 3px solid #2E86AB;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .metric-card {
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            padding: 20px;
            border-radius: 10px;
            border-left: 5px solid #2E86AB;
        }
        
        .metric-card h3 {
            color: #2E86AB;
            margin-bottom: 15px;
            font-size: 1.2em;
        }
        
        .metric-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            font-size: 0.9em;
        }
        
        .metric-table th, .metric-table td {
            padding: 8px 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        
        .metric-table th {
            background-color: #f8f9fa;
            font-weight: 600;
            color: #2E86AB;
        }
        
        .metric-table tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        
        .highlight {
            background: linear-gradient(45deg, #FFE066, #FF6B6B);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            color: #333;
        }
        
        .chart-container {
            margin: 30px 0;
            padding: 20px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .explanation {
            background: #e3f2fd;
            padding: 20px;
            border-radius: 10px;
            margin: 15px 0;
            border-left: 4px solid #2196f3;
        }
        
        .explanation h4 {
            color: #1976d2;
            margin-bottom: 10px;
        }
        
        .footer {
            background: #333;
            color: white;
            text-align: center;
            padding: 20px;
            border-radius: 10px;
            margin-top: 30px;
        }
        
        @media (max-width: 768px) {
            .metrics-grid {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2em;
            }
        }
        """
    
    def generate_markdown_report(self, output_path: Path, timestamp: str) -> Path:
        """마크다운 리포트 생성"""
        
        strategies = list(self.results.keys())
        periods = list(self.results[strategies[0]].keys())
        
        # 최고 성과 찾기
        best_return = -float('inf')
        best_sharpe = -float('inf')
        best_return_combo = ""
        best_sharpe_combo = ""
        
        for strategy in strategies:
            for period in periods:
                metrics = self.results[strategy][period]['metrics']
                
                if metrics['cagr'] > best_return:
                    best_return = metrics['cagr']
                    best_return_combo = f"{strategy}_{period}"
                
                if metrics['sharpe_ratio'] > best_sharpe:
                    best_sharpe = metrics['sharpe_ratio']
                    best_sharpe_combo = f"{strategy}_{period}"
        
        md_content = f"""# 📊 {self.portfolio_specs['name']} - 포트폴리오 분석 리포트

## 📋 기본 정보

- **분석 기간**: {self.portfolio_specs['start_date']} ~ {self.portfolio_specs['end_date']}
- **구성 종목**: {', '.join(self.portfolio_specs['tickers'])}
- **투자 비중**: {', '.join([f'{t}: {w:.1%}' for t, w in zip(self.portfolio_specs['tickers'], self.portfolio_specs['weights'])])}
- **거래일수**: {self.portfolio_specs['trading_days']}일
- **분석 전략**: {', '.join(strategies)}
- **리밸런싱 주기**: {', '.join(periods)}

## 🏆 핵심 결과

### 최고 성과 조합
- **최고 수익률**: {best_return_combo} - **{best_return:.2%}** CAGR
- **최고 샤프비율**: {best_sharpe_combo} - **{best_sharpe:.3f}**

## 📊 전략별 상세 성과

{self._generate_markdown_metrics_table()}

## 🎯 전략 분석

### Equal Weight (동일가중) 전략
- **특징**: 모든 종목에 동일한 비중 할당
- **장점**: 단순함, 자동 리밸런싱 효과, 중소형주 편향
- **단점**: 시가총액 무시, 고변동성 종목의 과도한 영향

### Volatility Parity (변동성 패리티) 전략  
- **특징**: 변동성에 반비례하여 비중 조정
- **장점**: 리스크 균등 분산, 안정적 수익
- **단점**: 복잡한 계산, 저변동성 자산 편향

## 📅 리밸런싱 주기 분석

{self._generate_markdown_rebalancing_analysis()}

## 📚 성과 지표 해설

### 수익률 지표
- **Total Return**: 투자 기간 동안의 전체 수익률
- **CAGR**: 연평균 복합성장률, 시간을 고려한 정확한 수익률
- **Volatility**: 수익률의 연율화된 표준편차, 위험도 측정

### 위험 조정 지표  
- **Sharpe Ratio**: 위험 대비 초과수익률, 높을수록 좋음
- **Sortino Ratio**: 하방 위험만 고려한 수익률 지표
- **Calmar Ratio**: 최대 낙폭 대비 수익률

### 위험 지표
- **Max Drawdown**: 최고점 대비 최대 하락폭
- **VaR (95%)**: 95% 신뢰도에서 예상 최대 일일 손실
- **CVaR**: VaR 초과 손실의 평균값

### 일관성 지표
- **Win Rate**: 양의 수익률 기록 비율
- **Profit Factor**: 평균 이익 대비 평균 손실 비율

## 💡 투자 가이드라인

### 보수적 투자자
- **추천**: Volatility Parity + 6M/1Y 리밸런싱
- **이유**: 낮은 변동성, 안정적 수익률 곡선

### 적극적 투자자
- **추천**: Equal Weight + 1M/3M 리밸런싱  
- **이유**: 높은 절대 수익률, 시장 기회 적극 활용

### 균형 투자자
- **추천**: 두 전략 혼합 + 3M 리밸런싱
- **이유**: 위험과 수익의 균형

## ⚠️ 주의사항

1. **과거 성과는 미래 수익을 보장하지 않습니다**
2. **거래비용이 실제 수익률에 영향을 줄 수 있습니다**
3. **시장 환경 변화에 따른 전략 효과성 변동 가능**
4. **분산투자를 통한 위험 관리가 중요합니다**

## 📈 결론

{self._generate_markdown_conclusion()}

---

*Generated by Stock Forecast Lab on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*
"""
        
        md_path = output_path / f"portfolio_report_{timestamp}.md"
        with open(md_path, 'w', encoding='utf-8') as f:
            f.write(md_content)
        
        return md_path
    
    def _generate_markdown_metrics_table(self) -> str:
        """마크다운 메트릭스 테이블 생성"""
        
        strategies = list(self.results.keys())
        periods = list(self.results[strategies[0]].keys())
        
        md = ""
        for strategy in strategies:
            md += f"\n### {strategy.replace('_', ' ').title()} Strategy\n\n"
            
            # 테이블 헤더
            md += "| Metric | " + " | ".join(periods) + " |\n"
            md += "|--------|" + "|".join(["--------"] * len(periods)) + "|\n"
            
            # 메트릭 데이터
            metric_info = [
                ('Total Return', 'total_return', '{:.2%}'),
                ('CAGR', 'cagr', '{:.2%}'),
                ('Volatility', 'volatility', '{:.2%}'),
                ('Sharpe Ratio', 'sharpe_ratio', '{:.3f}'),
                ('Sortino Ratio', 'sortino_ratio', '{:.3f}'),
                ('Max Drawdown', 'max_drawdown', '{:.2%}'),
                ('Win Rate', 'win_rate', '{:.2%}'),
                ('Rebalancing Cost', 'total_rebalancing_cost', '${:.0f}')
            ]
            
            for display_name, key, format_str in metric_info:
                md += f"| {display_name} |"
                for period in periods:
                    result = self.results[strategy][period]
                    if key in ['total_rebalancing_cost']:
                        value = result[key]
                    else:
                        value = result['metrics'][key]
                    
                    if pd.isna(value) or np.isinf(value):
                        formatted_value = 'N/A'
                    else:
                        try:
                            formatted_value = format_str.format(value)
                        except:
                            formatted_value = str(value)
                    
                    md += f" {formatted_value} |"
                md += "\n"
            
            md += "\n"
        
        return md
    
    def _generate_markdown_rebalancing_analysis(self) -> str:
        """마크다운 리밸런싱 분석 생성"""
        
        strategies = list(self.results.keys())
        periods = list(self.results[strategies[0]].keys())
        
        md = ""
        for period in periods:
            md += f"\n### {period} 리밸런싱 주기\n\n"
            
            for strategy in strategies:
                result = self.results[strategy][period]
                rebalance_count = result['rebalancing_count']
                total_cost = result['total_rebalancing_cost']
                
                md += f"**{strategy.replace('_', ' ').title()}**:\n"
                md += f"- 총 리밸런싱: {rebalance_count}회\n"
                md += f"- 총 거래비용: ${total_cost:.2f}\n"
                md += f"- 회당 평균: ${total_cost/max(rebalance_count, 1):.2f}\n\n"
        
        return md
    
    def _generate_markdown_conclusion(self) -> str:
        """마크다운 결론 생성"""
        
        strategies = list(self.results.keys())
        periods = list(self.results[strategies[0]].keys())
        
        # 간단한 결론 생성
        best_combo = ""
        best_cagr = -float('inf')
        
        for strategy in strategies:
            for period in periods:
                cagr = self.results[strategy][period]['metrics']['cagr']
                if cagr > best_cagr:
                    best_cagr = cagr
                    best_combo = f"{strategy}_{period}"
        
        conclusion = f"""
분석 결과, **{best_combo}** 조합이 **{best_cagr:.2%}**의 CAGR로 최고 성과를 기록했습니다.

투자자는 자신의 위험 성향과 투자 목표에 따라 적절한 전략과 리밸런싱 주기를 선택해야 합니다. 
높은 수익률을 추구한다면 적극적 전략을, 안정성을 중시한다면 보수적 전략을 고려하시기 바랍니다.

무엇보다 **분산투자와 꾸준한 모니터링**이 성공적인 포트폴리오 운용의 핵심입니다.
"""
        
        return conclusion